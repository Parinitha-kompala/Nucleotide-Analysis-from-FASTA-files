#!/usr/bin/env python3
"""
File: pdb_fasta_splitter.py

This program read in a file contains both fasta sequence and secondary structure sequence. Program will 
output (classify) fasta sequence and protein secondary structural sequence into separate files. In addition 
to classification, program will count number of valid sequence in each file as well. 

Help messages will guide user through the basic command/execution of the program when '-h' command is used.

Sample command for executing the program: 
python3 pdb_fasta_splitter.py --infile ss.txt
"""
import sys
import re
import argparse

def get_fh(filename, mode):
    """
    get_fh function will 1) read in file name. 2) open a file and 'read' or 'write'
    Purpose of the function is to open the file name passed in and pass back the file handle. 
    * All opening and closing of files in your program should use the get_fh function
    """
    fh = None
    try:
        if mode == 'r':
            fh = open(filename,'r')
        elif mode == 'w':
            fh = open(filename,'w')
        else:
            raise ValueError('Command should be r or w')
    except IOError as e:
        print(e)
    except ValueError as e:
        print(e)
    return fh

def get_header_and_sequence_lists(fh_in):
    """
    function will read in the file handle generated by the get_fh function and return two lists. 
    One list for the .fasta sequence and another list for headers of the sequence file.
    Sequence and sequence header should be one-to-one correspondent. 
    """
    temp = ''
    isSeq = isSecStr = False
    sequence_header = secstr_header = sequence = secstr = []
    for line in fh_in:
        if (isSeq | isSecStr) & (line[0] != ">"):
            temp += line.strip()
        elif line[0] == ">" & line.strip().endswith("sequence"):
            sequence_header.append(line.strip())
            isSeq = True
            isSecStr = False
            if temp != '':
                secstr.append(temp)
                temp = ''
        elif line[0] == ">" & line.strip().endswith("secstr"):
            secstr_header.append(element.strip())
            isSeq = False
            isSecStr = True
            if temp != '':
                secstr.append(temp)
                data = ''
    if isSeq & temp != '':
        sequence.append(temp)
    else:
        secstr.append(temp)
    _check_size_of_lists(sequence_header, secstr_header)
    return sequence_header, sequence, secstr_header, secstr

def _check_size_of_lists(sequence_header, secstr_header):
    """
    function will read in the header and sequence list (returned from get_header_and_sequence_lists). 
    function will initiate sys.exit if the size of the lists passed in are not the same. 
    "_" indicates for internal use.
    """
    if len(sequence_header) != len(sequence):
        sys.exit("The size of the sequence list and sequence header doesn't match")
    else:
        return True
 
def main():
    args = get_cli_args()
    file = args.file
    fh_in = get_fh(file,'r')
    list_headers, list_seqs, list_headers_ss, list_seqs_ss = get_header_and_sequence_lists(fh_in)
    print("Found " + str(len(list_seqs)) + " protein sequences")
    print("Found " + str(len(list_seqs_ss)) + " ss sequences")



def get_cli_args():
    parser = argparse.ArgumentParser(
    description = 'Seperating the sequence and secondary sequences')
    parser.add_argument('-f', '--infile',
                        dest = 'file',
                        type = str,
                        help = 'Path to the file to open',
                        required = True)

    return parser.parse_args()

if __name__ == '__main__':
    main()

    

